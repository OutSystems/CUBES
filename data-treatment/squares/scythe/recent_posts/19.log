R[write to console]: 
Attaching package: ‘dplyr’


R[write to console]: The following objects are masked from ‘package:stats’:

    filter, lag


R[write to console]: The following objects are masked from ‘package:base’:

    intersect, setdiff, setequal, union


R[write to console]: 
Attaching package: ‘dbplyr’


R[write to console]: The following objects are masked from ‘package:dplyr’:

    ident, sql


# First, specify the types that will be used

enum Cols {
  "Balance, CustomerID", "Balance, Date", "CustomerID, Balance", "CustomerID, Date", "Date, Balance", "Date, CustomerID", "Balance", "CustomerID", "Date"
}

enum Col {
  "Balance", "CustomerID", "Date"
}

enum SelectCols{
  "CustomerID,Balance,Date"
}

enum Distinct {
	"distinct", ""
}

enum FilterCondition{
"Balance == 0", "Balance > 0", "Balance < 0", "Balance >= 0", "Balance <= 0", "Date == 0", "Date > 0", "Date < 0", "Date >= 0", "Date <= 0", "maxBalance == 0", "maxBalance > 0", "maxBalance < 0", "maxBalance >= 0", "maxBalance <= 0", "maxDate == 0", "maxDate > 0", "maxDate < 0", "maxDate >= 0", "maxDate <= 0", "Balance == maxBalance", "Balance > maxBalance", "Balance < maxBalance", "Balance >= maxBalance", "Balance <= maxBalance", "Date == maxBalance", "Date > maxBalance", "Date < maxBalance", "Date >= maxBalance", "Date <= maxBalance", "maxDate == maxBalance", "maxDate > maxBalance", "maxDate < maxBalance", "maxDate >= maxBalance", "maxDate <= maxBalance", "Balance == maxDate", "Balance > maxDate", "Balance < maxDate", "Balance >= maxDate", "Balance <= maxDate", "Date == maxDate", "Date > maxDate", "Date < maxDate", "Date >= maxDate", "Date <= maxDate", "maxBalance == maxDate", "maxBalance > maxDate", "maxBalance < maxDate", "maxBalance >= maxDate", "maxBalance <= maxDate"
}

enum SummariseCondition{
"maxBalance = max(Balance)", "maxDate = max(Date)"
}

enum Op{
 "|", "&"
}

value Table {
  col: int;
  row: int;
}

value TableSelect {
  col: int;
  row: int;
}

value Empty;

# Next, specify the input/output of the synthesized program
program Squares(Table) -> TableSelect;

# Finally, specify the production rules
func empty: Empty -> Empty;

func inner_join: Table r -> Table a, Table b
{
  col(r) <= col(a) + col(b);
}

func inner_join3: Table r -> Table a, Table b, Table c
{
  col(r) < col(a) + col(b) + col(c);
}

func inner_join4: Table r -> Table a, Table b, Table c, Table d {
  col(r) < col(a) + col(b) + col(c) + col(d);
}

func anti_join: Table r ->  Table a, Table b, Col c {
  #col(r) <= col(a) + col(b);
  col(r) == 1;
  row(r) <= row(a);
}

func left_join: Table r ->  Table a, Table b{
  col(r) <= col(a) + col(b);
  row(r) == row(a);
}

func bind_rows: Table r ->  Table a, Table b{
  col(r) <= col(a) + col(b);
  row(r) == row(a) + row(b);
}

func intersect: Table r ->  Table a, Table b, Col c {
  #col(r) <= col(a) + col(b);
  col(r) == 1;
  row(r) <= row(a);
}

func select: TableSelect r -> Table a, SelectCols c, Distinct d{
	row(r) <= row(a);
	col(r) <= col(a);
}




func filter: Table r -> Table a, FilterCondition f {
 row(r) <= row(a);
 col(r) == col(a);
}
func filters: Table r -> Table a, FilterCondition f, FilterCondition g, Op o {
 row(r) <= row(a);
 col(r) == col(a);
}


func summariseGrouped: Table r -> Table a, SummariseCondition s, Cols b {
 row(r) <= row(a);
 col(r) <= 3;
}

predicate is_not_parent(inner_join4, summariseGrouped, 100);
predicate is_not_parent(summariseGrouped, summariseGrouped, 100);
predicate distinct_filters(filters, 1, 2);

predicate is_not_parent(filters, filter, 100);
predicate is_not_parent(filter, filters, 100);
predicate is_not_parent(filter, filter, 100);
predicate is_not_parent(filters, filters, 100);

predicate constant_occurs("maxBalance = max(Balance),maxDate = max(Date)");
predicate constant_occurs("Balance == 0,Balance > 0,Balance < 0,Balance >= 0,Balance <= 0,Date == 0,Date > 0,Date < 0,Date >= 0,Date <= 0,maxBalance == 0,maxBalance > 0,maxBalance < 0,maxBalance >= 0,maxBalance <= 0,maxDate == 0,maxDate > 0,maxDate < 0,maxDate >= 0,maxDate <= 0");
predicate happens_before("Balance == maxBalance","maxBalance = max(Balance)");
predicate happens_before("Balance > maxBalance","maxBalance = max(Balance)");
predicate happens_before("Balance < maxBalance","maxBalance = max(Balance)");
predicate happens_before("Balance >= maxBalance","maxBalance = max(Balance)");
predicate happens_before("Balance <= maxBalance","maxBalance = max(Balance)");
predicate happens_before("Date == maxBalance","maxBalance = max(Balance)");
predicate happens_before("Date > maxBalance","maxBalance = max(Balance)");
predicate happens_before("Date < maxBalance","maxBalance = max(Balance)");
predicate happens_before("Date >= maxBalance","maxBalance = max(Balance)");
predicate happens_before("Date <= maxBalance","maxBalance = max(Balance)");
predicate happens_before("maxDate == maxBalance","maxBalance = max(Balance)");
predicate happens_before("maxDate > maxBalance","maxBalance = max(Balance)");
predicate happens_before("maxDate < maxBalance","maxBalance = max(Balance)");
predicate happens_before("maxDate >= maxBalance","maxBalance = max(Balance)");
predicate happens_before("maxDate <= maxBalance","maxBalance = max(Balance)");
predicate happens_before("Balance == maxDate","maxDate = max(Date)");
predicate happens_before("Balance > maxDate","maxDate = max(Date)");
predicate happens_before("Balance < maxDate","maxDate = max(Date)");
predicate happens_before("Balance >= maxDate","maxDate = max(Date)");
predicate happens_before("Balance <= maxDate","maxDate = max(Date)");
predicate happens_before("Date == maxDate","maxDate = max(Date)");
predicate happens_before("Date > maxDate","maxDate = max(Date)");
predicate happens_before("Date < maxDate","maxDate = max(Date)");
predicate happens_before("Date >= maxDate","maxDate = max(Date)");
predicate happens_before("Date <= maxDate","maxDate = max(Date)");
predicate happens_before("maxBalance == maxDate","maxDate = max(Date)");
predicate happens_before("maxBalance > maxDate","maxDate = max(Date)");
predicate happens_before("maxBalance < maxDate","maxDate = max(Date)");
predicate happens_before("maxBalance >= maxDate","maxDate = max(Date)");
predicate happens_before("maxBalance <= maxDate","maxDate = max(Date)");
predicate is_not_parent(inner_join, inner_join3, 100);
predicate is_not_parent(inner_join, inner_join4, 100);
#predicate is_not_parent(inner_join, anti_join, 100);
predicate is_not_parent(inner_join3, inner_join, 100);
predicate is_not_parent(inner_join3, inner_join3, 100);
predicate is_not_parent(inner_join3, inner_join4, 100);
predicate is_not_parent(inner_join3, anti_join, 100);
predicate is_not_parent(inner_join4, inner_join, 100);
predicate is_not_parent(inner_join4, inner_join3, 100);
predicate is_not_parent(inner_join4, inner_join4, 100);
#predicate is_not_parent(inner_join4, anti_join, 100);
predicate is_not_parent(anti_join, anti_join, 100);
predicate is_not_parent(anti_join, inner_join, 100);
predicate is_not_parent(anti_join, inner_join4, 100);
predicate distinct_inputs(inner_join4);
predicate distinct_inputs(inner_join3);
predicate distinct_inputs(inner_join);
predicate distinct_inputs(anti_join);

