R[write to console]: 
Attaching package: ‘dplyr’


R[write to console]: The following objects are masked from ‘package:stats’:

    filter, lag


R[write to console]: The following objects are masked from ‘package:base’:

    intersect, setdiff, setequal, union


R[write to console]: 
Attaching package: ‘dbplyr’


R[write to console]: The following objects are masked from ‘package:dplyr’:

    ident, sql


# First, specify the types that will be used

enum Cols {
  "Banned, City_Id", "Banned, Client_Id", "Banned, Driver_Id", "Banned, Id", "Banned, Request_at", "Banned, Role", "Banned, Status", "Banned, Users_Id", "City_Id, Banned", "City_Id, Client_Id", "City_Id, Driver_Id", "City_Id, Id", "City_Id, Request_at", "City_Id, Role", "City_Id, Status", "City_Id, Users_Id", "Client_Id, Banned", "Client_Id, City_Id", "Client_Id, Driver_Id", "Client_Id, Id", "Client_Id, Request_at", "Client_Id, Role", "Client_Id, Status", "Client_Id, Users_Id", "Driver_Id, Banned", "Driver_Id, City_Id", "Driver_Id, Client_Id", "Driver_Id, Id", "Driver_Id, Request_at", "Driver_Id, Role", "Driver_Id, Status", "Driver_Id, Users_Id", "Id, Banned", "Id, City_Id", "Id, Client_Id", "Id, Driver_Id", "Id, Request_at", "Id, Role", "Id, Status", "Id, Users_Id", "Request_at, Banned", "Request_at, City_Id", "Request_at, Client_Id", "Request_at, Driver_Id", "Request_at, Id", "Request_at, Role", "Request_at, Status", "Request_at, Users_Id", "Role, Banned", "Role, City_Id", "Role, Client_Id", "Role, Driver_Id", "Role, Id", "Role, Request_at", "Role, Status", "Role, Users_Id", "Status, Banned", "Status, City_Id", "Status, Client_Id", "Status, Driver_Id", "Status, Id", "Status, Request_at", "Status, Role", "Status, Users_Id", "Users_Id, Banned", "Users_Id, City_Id", "Users_Id, Client_Id", "Users_Id, Driver_Id", "Users_Id, Id", "Users_Id, Request_at", "Users_Id, Role", "Users_Id, Status", "Banned", "City_Id", "Client_Id", "Driver_Id", "Id", "Request_at", "Role", "Status", "Users_Id"
}

enum Col {
  "Banned", "City_Id", "Client_Id", "Driver_Id", "Id", "Request_at", "Role", "Status", "Users_Id"
}

enum SelectCols{
  "Day,CancellationRate"
}

enum Distinct {
	"distinct", ""
}



enum Op{
 "|", "&"
}

value Table {
  col: int;
  row: int;
}

value TableSelect {
  col: int;
  row: int;
}

value Empty;

# Next, specify the input/output of the synthesized program
program Squares(Table, Table) -> TableSelect;

# Finally, specify the production rules
func empty: Empty -> Empty;

func inner_join: Table r -> Table a, Table b
{
  col(r) <= col(a) + col(b);
}

func inner_join3: Table r -> Table a, Table b, Table c
{
  col(r) < col(a) + col(b) + col(c);
}

func inner_join4: Table r -> Table a, Table b, Table c, Table d {
  col(r) < col(a) + col(b) + col(c) + col(d);
}

func anti_join: Table r ->  Table a, Table b, Col c {
  #col(r) <= col(a) + col(b);
  col(r) == 1;
  row(r) <= row(a);
}

func left_join: Table r ->  Table a, Table b{
  col(r) <= col(a) + col(b);
  row(r) == row(a);
}

func bind_rows: Table r ->  Table a, Table b{
  col(r) <= col(a) + col(b);
  row(r) == row(a) + row(b);
}

func intersect: Table r ->  Table a, Table b, Col c {
  #col(r) <= col(a) + col(b);
  col(r) == 1;
  row(r) <= row(a);
}

func select: TableSelect r -> Table a, SelectCols c, Distinct d{
	row(r) <= row(a);
	col(r) <= col(a);
}




func filters: Table r -> Table a, FilterCondition f, FilterCondition g, Op o {
 row(r) <= row(a);
 col(r) == col(a);
}


predicate distinct_filters(filters, 1, 2);
predicate is_not_parent(filters, filters, 100);
predicate is_not_parent(inner_join, filters, 100);
predicate is_not_parent(inner_join3, filters, 100);
predicate is_not_parent(inner_join4, filters, 100);
predicate distinct_inputs(filters);

predicate is_not_parent(inner_join, inner_join3, 100);
predicate is_not_parent(inner_join, inner_join4, 100);
#predicate is_not_parent(inner_join, anti_join, 100);
predicate is_not_parent(inner_join3, inner_join, 100);
predicate is_not_parent(inner_join3, inner_join3, 100);
predicate is_not_parent(inner_join3, inner_join4, 100);
predicate is_not_parent(inner_join3, anti_join, 100);
predicate is_not_parent(inner_join4, inner_join, 100);
predicate is_not_parent(inner_join4, inner_join3, 100);
predicate is_not_parent(inner_join4, inner_join4, 100);
#predicate is_not_parent(inner_join4, anti_join, 100);
predicate is_not_parent(anti_join, anti_join, 100);
predicate is_not_parent(anti_join, inner_join, 100);
predicate is_not_parent(anti_join, inner_join4, 100);
predicate distinct_inputs(inner_join4);
predicate distinct_inputs(inner_join3);
predicate distinct_inputs(inner_join);
predicate distinct_inputs(anti_join);

