R[write to console]: 
Attaching package: ‘dplyr’


R[write to console]: The following objects are masked from ‘package:stats’:

    filter, lag


R[write to console]: The following objects are masked from ‘package:base’:

    intersect, setdiff, setequal, union


R[write to console]: 
Attaching package: ‘dbplyr’


R[write to console]: The following objects are masked from ‘package:dplyr’:

    ident, sql


# First, specify the types that will be used

enum Cols {
  "area, continent", "area, gdp", "area, name", "area, population", "continent, area", "continent, gdp", "continent, name", "continent, population", "gdp, area", "gdp, continent", "gdp, name", "gdp, population", "name, area", "name, continent", "name, gdp", "name, population", "population, area", "population, continent", "population, gdp", "population, name", "area", "continent", "gdp", "name", "population"
}

enum Col {
  "area", "continent", "gdp", "name", "population"
}

enum SelectCols{
  "name,area,population"
}

enum Distinct {
	"distinct", ""
}

enum FilterCondition{
"area == 3000000", "area > 3000000", "area < 3000000", "area >= 3000000", "area <= 3000000", "population == 3000000", "population > 3000000", "population < 3000000", "population >= 3000000", "population <= 3000000", "area == 25000000", "area > 25000000", "area < 25000000", "area >= 25000000", "area <= 25000000", "population == 25000000", "population > 25000000", "population < 25000000", "population >= 25000000", "population <= 25000000"
}


enum Op{
 "|", "&"
}

value Table {
  col: int;
  row: int;
}

value TableSelect {
  col: int;
  row: int;
}

value Empty;

# Next, specify the input/output of the synthesized program
program Squares(Table) -> TableSelect;

# Finally, specify the production rules
func empty: Empty -> Empty;

func inner_join: Table r -> Table a, Table b
{
  col(r) <= col(a) + col(b);
}

func inner_join3: Table r -> Table a, Table b, Table c
{
  col(r) < col(a) + col(b) + col(c);
}

func inner_join4: Table r -> Table a, Table b, Table c, Table d {
  col(r) < col(a) + col(b) + col(c) + col(d);
}

func anti_join: Table r ->  Table a, Table b, Col c {
  #col(r) <= col(a) + col(b);
  col(r) == 1;
  row(r) <= row(a);
}

func left_join: Table r ->  Table a, Table b{
  col(r) <= col(a) + col(b);
  row(r) == row(a);
}

func bind_rows: Table r ->  Table a, Table b{
  col(r) <= col(a) + col(b);
  row(r) == row(a) + row(b);
}

func intersect: Table r ->  Table a, Table b, Col c {
  #col(r) <= col(a) + col(b);
  col(r) == 1;
  row(r) <= row(a);
}

func select: TableSelect r -> Table a, SelectCols c, Distinct d{
	row(r) <= row(a);
	col(r) <= col(a);
}




func filter: Table r -> Table a, FilterCondition f {
 row(r) <= row(a);
 col(r) == col(a);
}
func filters: Table r -> Table a, FilterCondition f, FilterCondition g, Op o {
 row(r) <= row(a);
 col(r) == col(a);
}


predicate distinct_filters(filters, 1, 2);

predicate is_not_parent(filters, filter, 100);
predicate is_not_parent(filter, filters, 100);
predicate is_not_parent(filter, filter, 100);
predicate is_not_parent(filters, filters, 100);

predicate constant_occurs("area == 3000000,area > 3000000,area < 3000000,area >= 3000000,area <= 3000000,population == 3000000,population > 3000000,population < 3000000,population >= 3000000,population <= 3000000");
predicate constant_occurs("area == 25000000,area > 25000000,area < 25000000,area >= 25000000,area <= 25000000,population == 25000000,population > 25000000,population < 25000000,population >= 25000000,population <= 25000000");
predicate is_not_parent(inner_join, inner_join3, 100);
predicate is_not_parent(inner_join, inner_join4, 100);
#predicate is_not_parent(inner_join, anti_join, 100);
predicate is_not_parent(inner_join3, inner_join, 100);
predicate is_not_parent(inner_join3, inner_join3, 100);
predicate is_not_parent(inner_join3, inner_join4, 100);
predicate is_not_parent(inner_join3, anti_join, 100);
predicate is_not_parent(inner_join4, inner_join, 100);
predicate is_not_parent(inner_join4, inner_join3, 100);
predicate is_not_parent(inner_join4, inner_join4, 100);
#predicate is_not_parent(inner_join4, anti_join, 100);
predicate is_not_parent(anti_join, anti_join, 100);
predicate is_not_parent(anti_join, inner_join, 100);
predicate is_not_parent(anti_join, inner_join4, 100);
predicate distinct_inputs(inner_join4);
predicate distinct_inputs(inner_join3);
predicate distinct_inputs(inner_join);
predicate distinct_inputs(anti_join);


------------------------------------- R Solution ---------------------------------------

con <- DBI::dbConnect(RSQLite::SQLite(), ":memory:")
input0 <- read.table("tests-examples/leetcode/tables/595.csv", sep =",", header=T)
input0
input0 <- copy_to(con,input0)
expected_output <- read.table("tests-examples/leetcode/tables/595_o.csv", sep =",", header=T)
expected_output

RET_DF111 <- input0 %>% ungroup() %>% filter(area == 3000000 | population > 25000000)
RET_DF112 <- RET_DF111 %>% ungroup() %>% select(name,area,population) %>% distinct()



+++++++++++++++++++++++++++++++++++++ SQL Solution +++++++++++++++++++++++++++++++++++++

SELECT DISTINCT `name`,
                `area`,
                `population`
FROM `input0`
WHERE (`area` = 3000000.0
       OR `population` > 25000000.0)

